# Kế hoạch Triển khai: Tính năng Phủ định Search Term bằng AI (AI-Powered Search Term Negation)

## 1. Tổng quan & Mục tiêu

Tài liệu này mô tả kế hoạch chi tiết để triển khai một loại Rule tự động hóa mới: **Phủ định Search Term bằng AI**. Tính năng này sẽ tự động hóa việc xác định và phủ định các cụm từ tìm kiếm (search terms) không liên quan, giúp giảm chi tiêu lãng phí và cải thiện mức độ liên quan của quảng cáo.

**Mục tiêu chính:**
-   Tạo một loại rule mới `AI_SEARCH_TERM_NEGATION`.
-   Hệ thống sẽ tự động chạy hàng ngày, phân tích dữ liệu search term của 3 ngày trước (D-3) để đảm bảo dữ liệu đã ổn định.
-   Với mỗi search term thỏa mãn điều kiện cơ bản (ví dụ: `spend > $X` và `orders = 0`), hệ thống sẽ sử dụng AI (Google Gemini) để đánh giá mức độ liên quan của search term đó với sản phẩm (ASIN) tương ứng.
-   Nếu AI xác định search term là **không liên quan**, hệ thống sẽ tự động tạo một từ khóa phủ định chính xác (Negative Exact) cho search term đó.
-   Tính năng này ban đầu chỉ áp dụng cho các search term là từ khóa, bỏ qua các search term là ASIN.

---

## 2. Quy trình Xử lý ở Quy mô lớn (100-1000+ Campaigns)

Việc xử lý hàng nghìn chiến dịch đòi hỏi một quy trình được tối ưu hóa để tránh các vấn đề về hiệu suất và giới hạn API. Dưới đây là cách hệ thống xử lý khối lượng công việc lớn một cách hiệu quả.

### Bước 1: Lấy Dữ liệu Nguồn Hàng loạt (Bulk Data Fetch)

-   **Hành động:** Thay vì lặp qua từng chiến dịch, hệ thống sẽ thực hiện một **câu lệnh SQL duy nhất** để lấy tất cả dữ liệu search term cho **tất cả các chiến dịch** trong phạm vi (scope) của rule.
-   **Tối ưu hóa:** Câu lệnh `SELECT` sẽ sử dụng điều kiện `WHERE campaign_id = ANY($1::bigint[])`, trong đó `$1` là một mảng chứa ID của tất cả 100, 1000, hoặc nhiều hơn các chiến dịch. PostgreSQL được tối ưu hóa để xử lý hiệu quả các truy vấn này, ngay cả trên hàng triệu dòng dữ liệu.
-   **Kết quả:** Toàn bộ dữ liệu D-3 cần thiết được tải vào bộ nhớ của server trong một lần duy nhất, giảm thiểu tối đa độ trễ khi tương tác với database.

### Bước 2: Lọc và Nhóm Dữ liệu trong Bộ nhớ (In-Memory Filtering & Grouping)

-   **Hành động:** Với tập dữ liệu lớn đã có, server sẽ nhanh chóng lặp qua và:
    1.  Loại bỏ các dòng không thỏa mãn điều kiện cơ bản (`spend`, `orders`).
    2.  Loại bỏ các search term là ASIN.
    3.  **Nhóm tất cả các search term còn lại theo ASIN của sản phẩm**. Thao tác này tạo ra một cấu trúc dữ liệu hiệu quả, ví dụ: `Map<ASIN, SearchTermInfo[]>`, để biết chính xác cần lấy thông tin chi tiết cho những ASIN nào.

### Bước 3: Lấy Dữ liệu Sản phẩm Hàng loạt (Batched Context Fetching)

-   **Vấn đề:** Việc gọi SP-API cho từng ASIN một sẽ rất chậm và dễ bị giới hạn (rate limiting).
-   **Giải pháp (Batching & Caching):**
    1.  Hệ thống lấy danh sách tất cả các ASIN duy nhất cần phân tích từ Bước 2.
    2.  Nó sẽ gọi SP-API `catalogItems` theo **lô (batch)**, mỗi lần lấy thông tin cho 20 ASIN (đây là giới hạn của API).
    3.  Các lệnh gọi API theo lô này có thể được thực hiện **song song (parallelism)** bằng `Promise.all` để tăng tốc độ.
    4.  Thông tin sản phẩm (title, bullet points) sẽ được lưu vào một **bộ nhớ đệm tạm thời (cache)** trong suốt quá trình chạy. Nếu 50 search term khác nhau đều trỏ đến cùng một ASIN, hệ thống chỉ cần gọi API một lần duy nhất cho ASIN đó.

### Bước 4: Đánh giá bằng AI Song song (Parallel AI Evaluation)

-   **Vấn đề:** Gửi hàng nghìn yêu cầu đến Gemini API một cách tuần tự sẽ là điểm nghẽn lớn nhất.
-   **Giải pháp (Parallelism with Rate Limiting):**
    1.  Hệ thống tạo ra một hàng đợi (queue) gồm tất cả các cặp `(search term, product details)` cần đánh giá.
    2.  Nó sẽ xử lý hàng đợi này bằng cách gửi nhiều yêu cầu đến Gemini API **cùng một lúc** (ví dụ: 10-20 yêu cầu song song).
    3.  Sau mỗi lô yêu cầu song song, hệ thống sẽ có một khoảng dừng ngắn (ví dụ: 1 giây) để đảm bảo không vượt quá giới hạn số lượng truy vấn mỗi phút (QPM) của Gemini API.
    4.  Kết quả 'YES'/'NO' từ mỗi yêu cầu sẽ được thu thập một cách bất đồng bộ.

### Bước 5: Tổng hợp Hành động Hàng loạt (Bulk Action Aggregation)

-   **Hành động:** Khi các kết quả từ AI trả về, hệ thống sẽ không thực hiện hành động ngay lập tức. Thay vào đó, nó sẽ thu thập tất cả các search term được đánh giá là 'NO' và nhóm chúng lại theo `campaignId` và `adGroupId` dựa trên **Phạm vi Tác động** đã chọn (xem phần 5).
-   **Kết quả:** Một cấu trúc dữ liệu được tạo ra, sẵn sàng cho việc tạo từ khóa phủ định hàng loạt, ví dụ: `Map<AdGroupId, NegativeKeywordInfo[]>`.

### Bước 6: Thực thi Hành động Hàng loạt (Bulk API Execution)

-   **Giải pháp (Bulk API):** Amazon Ads API cho phép tạo nhiều từ khóa phủ định trong **một lệnh gọi API duy nhất** (tối đa 1000 từ khóa mỗi lần).
-   **Hành động:** Hệ thống sẽ lặp qua cấu trúc dữ liệu từ Bước 5. Với mỗi `adGroupId`, nó sẽ tạo một yêu cầu `POST /sp/negativeKeywords` chứa tất cả các từ khóa phủ định cần thiết cho ad group đó.
-   **Hiệu quả:** Thay vì thực hiện 500 lệnh gọi API riêng lẻ để phủ định 500 search term, hệ thống có thể chỉ cần thực hiện vài lệnh gọi API hàng loạt, giúp giảm đáng kể thời gian và tránh bị giới hạn API.

### Bước 7: Ghi Log (Logging)

-   **Hành động:** Toàn bộ kết quả, bao gồm các search term đã được phủ định và lý do, sẽ được tổng hợp lại và ghi vào bảng `automation_logs` trong một giao dịch (transaction) duy nhất.

---

## 3. Tóm tắt các Chiến lược Mở rộng Quy mô

Hệ thống được thiết kế để xử lý khối lượng lớn thông qua các nguyên tắc cốt lõi sau:
-   **Truy vấn Database Hiệu quả:** Lấy tất cả dữ liệu cần thiết trong một câu lệnh duy nhất.
-   **Xử lý Hàng loạt (Batching):** Nhóm các lệnh gọi API (lấy thông tin sản phẩm, tạo từ khóa phủ định) lại để giảm số lượng yêu cầu.
-   **Xử lý Song song (Parallelism):** Thực hiện nhiều tác vụ độc lập (như gọi API) cùng một lúc để tiết kiệm thời gian.
-   **Bộ nhớ đệm (Caching):** Tránh việc lấy lại thông tin đã có (như chi tiết sản phẩm) nhiều lần trong một lần chạy.
-   **Tôn trọng Giới hạn API (Rate Limiting):** Thêm các khoảng nghỉ ngắn giữa các lô yêu cầu để đảm bảo hệ thống hoạt động ổn định và không bị chặn.

---

## 4. Ước tính Hiệu suất và Chi phí

-   **Thời gian xử lý:** Với 1000 chiến dịch và khoảng 5000 search term cần phân tích, toàn bộ quá trình dự kiến sẽ mất từ **5 đến 15 phút** để hoàn thành, tùy thuộc vào độ trễ của các API.
-   **Chi phí:**
    -   **Amazon API (SP-API & Ads API):** Miễn phí.
    -   **Google Gemini API:** Chi phí sẽ **cực kỳ thấp**. Với mô hình `gemini-2.5-flash`, việc phân tích 5000 search term (mỗi prompt rất ngắn) có thể chỉ tốn **vài cent đô la Mỹ**.

---

## 5. (Nâng cao) Phạm vi Tác động của Rule (Rule Impact Scope)

Để tăng cường tính linh hoạt chiến lược, rule `AI_SEARCH_TERM_NEGATION` sẽ có một tùy chọn cấu hình mới là `negationScope`. Người dùng có thể chọn một trong các cấp độ sau:

#### 5.1. `AD_GROUP` (Mặc định)
-   **Hành động:** Nếu search term "X" được phát hiện là không liên quan trong **Ad Group A**, hệ thống sẽ chỉ phủ định "X" trong **Ad Group A**.
-   **Ưu điểm:** An toàn và chính xác nhất, không ảnh hưởng đến các ad group khác.
-   **Nhược điểm:** Có thể phải lặp lại hành động nếu cùng một search term không hiệu quả xuất hiện ở nhiều ad group.

#### 5.2. `CAMPAIGN`
-   **Hành động:** Nếu search term "X" được phát hiện là không liên quan trong Ad Group A của **Campaign A**, hệ thống sẽ phủ định "X" trong **tất cả các ad group** thuộc **Campaign A**.
-   **Ưu điểm:** Dọn dẹp hiệu quả ở cấp độ chiến dịch, tiết kiệm thời gian.
-   **Nhược điểm:** Có thể phủ định nhầm ở một ad group khác trong cùng chiến dịch nơi search term đó lại có thể phù hợp (trường hợp hiếm).

#### 5.3. `ACCOUNT_BY_ASIN`
-   **Hành động:** Nếu search term "X" được phát hiện là không liên quan cho sản phẩm **ASIN123** trong bất kỳ ad group nào, hệ thống sẽ tìm kiếm và phủ định "X" trong **tất cả các ad group của tất cả các campaign** đang quảng cáo cho **ASIN123**.
-   **Ưu điểm:** Tối đa hóa hiệu quả, chỉ cần AI đánh giá một lần là có thể áp dụng trên toàn bộ tài khoản cho sản phẩm đó.
-   **Nhược điểm:** Rủi ro cao nhất nếu AI đánh giá sai. Cần sử dụng một cách thận trọng, đặc biệt với các search term chung chung.

### 5.4. Thay đổi ở Backend (Rules Engine)

-   Khi xử lý một search term được AI đánh giá là `NO`, evaluator sẽ:
    1.  Đọc giá trị `negationScope` từ `rule.config`.
    2.  **Nếu là `AD_GROUP`:** Thêm hành động phủ định cho ad group gốc.
    3.  **Nếu là `CAMPAIGN`:** Truy vấn database để lấy tất cả các `ad_group_id` thuộc `campaign_id` gốc, sau đó thêm hành động phủ định cho tất cả các ad group đó.
    4.  **Nếu là `ACCOUNT_BY_ASIN`:** Thực hiện một truy vấn phức tạp hơn để tìm tất cả các `campaign_id` và `ad_group_id` đang quảng cáo cho `asin` của sản phẩm, sau đó thêm hành động phủ định cho tất cả chúng.
    5.  Tất cả các hành động phủ định đã thu thập sẽ được gom lại để thực thi hàng loạt.

### 5.5. Thay đổi ở Frontend (Rule Builder)

-   Trong modal tạo/sửa rule `AI_SEARCH_TERM_NEGATION`, thêm một dropdown mới:
    -   **Label:** "Phạm vi Áp dụng Phủ định" (Negative Application Scope).
    -   **Options:** "Chỉ Ad Group này" (`AD_GROUP`), "Toàn bộ Campaign" (`CAMPAIGN`), "Toàn bộ Tài khoản (theo ASIN)" (`ACCOUNT_BY_ASIN`).
    -   Thêm một dòng chú thích giải thích ngắn gọn về từng tùy chọn.